---
title: "Analysis of electric vehicle usage patterns in New Zealand"
subtitle: "Statistical Report"
author: "Rafferty Parker and Ben Anderson (ben.anderson@otago.ac.nz), [Centre for Sustainability](https://www.otago.ac.nz/centre-sustainability/), University of Otago"
date: 'Last run at: `r Sys.time()`'
output:
  bookdown::html_document2:
    code_folding: hide
    fig_caption: yes
    number_sections: yes
    self_contained: no
    toc: yes
    toc_depth: 2
    toc_float: yes
  bookdown::pdf_document2:
    fig_caption: yes
    keep_tex: yes
    number_sections: yes
    toc: yes
    toc_depth: 2
  bookdown::word_document2:
    fig_caption: yes
    toc: yes
    toc_depth: 2
always_allow_html: yes
bibliography: "../../EVBBmendeleyrefs.bib"  
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = FALSE)
knitr::opts_chunk$set(warning = FALSE) # for final tidy run
knitr::opts_chunk$set(message = FALSE) # for final tidy run

library(readr) # tidy data reading
library(data.table) # cos we like data.table (you may not in which case dplyr is fine :-)
library(lubridate) # for data & time manip
library(hms) # for hh:mm:ss if we need it
library(ggplot2) # fancy plots
library(ggjoy)
library(dplyr) # for filter
library(forcats) # used to reverse days of week in joy plots
library(knitr) # for knitting
library(kableExtra) # for extra kable
library(skimr) # for skim (data description)

# colour blind palettes for charts
# http://www.cookbook-r.com/Graphs/Colors_(ggplot2)/#a-colorblind-friendly-palette
# with grey
cbgPalette <- c("#999999", "#E69F00", "#56B4E9", "#009E73", "#F0E442", "#0072B2", "#D55E00", "#CC79A7")
# with black
cbbPalette <- c("#000000", "#E69F00", "#56B4E9", "#009E73", "#F0E442", "#0072B2", "#D55E00", "#CC79A7")

# data file to use
file <- "EVBB_processed_all_v1.0_20180125.csv"
# for Mac
user <- Sys.info()[[7]]
if(user == "ben"){
  dPath <- "/Volumes/hum-csafe/Research Projects/GREEN Grid/externalData/flipTheFleet/safe/testData/2019_01_25/"
  dFile <- paste0(dPath, file, ".zip") # use zipped data
  if(!file.exists(dFile)) {
    # we probably don't have the HCS mounted so switch to local
    dPath <- "~/Data/NZ_GREENGrid/ftf/"
    dFile <- paste0(dPath, file, ".zip")
  }
} else {
  # for Xubuntu:
  dPath <- "/run/user/1001/gvfs/smb-share:server=storage.hcs-p01.otago.ac.nz,share=hum-csafe,user=student%5Cparra358/Research Projects/GREEN Grid/externalData/flipTheFleet/safe/testData/2019_01_25/"
  dFile <- paste0(dPath, "EVBB_processed_all_v1.0_20180125.csv")
}
```

```{r loadData, include=FALSE}
print(paste0("Using ", dFile))
rawDF <- readr::read_csv(dFile) # creates a tidyverse tibble https://www.tidyverse.org/articles/2018/01/tibble-1-4-1/
# remove location var as it is NA but may lead to readers/ftf members thinking we know their location when we don't
rawDF$location <- NULL

# remove the dayid & fractime as we don't need them
rawDF$dayid <- NULL
rawDF$fractime <- NULL

# tbh the month & day_of_week vars aren't needed either as we have the date...
```


```{r processData, include=FALSE}
# convert to data.table as much faster
rawDT <- data.table::as.data.table(rawDF) # so we can do data.table stuff
#Combine date and time columns into POSIXct datetime ----
rawDT <- rawDT[,dateTime := lubridate::as_datetime(paste0(date, time))]
#df$dateTime <- lubridate::as_datetime(paste0(df$date, df$time))

# set correct order for days of the week ----
rawDT <- rawDT[, day_of_week := ordered(day_of_week, 
                                        levels=c("Monday", "Tuesday", "Wednesday",
                                                   "Thursday", "Friday", "Saturday", "Sunday"))]
# set charge type ----
rawDT <- rawDT[, chargeType := ifelse(charge_power_kw == 0, "Not charging", NA)]
rawDT <- rawDT[, chargeType := ifelse(charge_power_kw > 0, "Standard charging", chargeType)]
rawDT <- rawDT[, chargeType := ifelse(charge_power_kw > 7, "Fast charging", chargeType)]

# Rename vehicle ids to something more user-friendly ----
rawDT <- rawDT[,dvID := factor(id, ordered = TRUE)]
levSeq <- seq(1:length(levels(rawDT$dvID)))
levSeqChar <- as.character(levSeq)
rawDT <- rawDT[, dvID := factor(dvID,
  labels = levSeqChar)]
rawDT <- rawDT[, dvID := paste("Vehicle", dvID, sep = " ")]

rawDT <- setnames(rawDT, c("state_of_charge_percent"), c("SoC_percent"))

rawDT <- rawDT[, qHour := hms::trunc_hms(time, 15*60)] # truncate to previous 15 min
#df$qHour <- format(as.POSIXct(hms::trunc_hms(df$time, 15*60)), "%H:%M")

# Month as ordered factor ----
rawDT <- rawDT[, month := factor(month, levels = c("Jan", "Feb", "Mar", "Apr", "May",
                                                        "Jun", "Jul", "Aug", "Sep", "Oct",
                                                        "Nov", "Dec"))]


# Create factor for weekdays/weekends ----
rawDT <- rawDT[, weekdays := "Weekdays"]
rawDT <- rawDT[, weekdays := ifelse(day_of_week == "Saturday" |
                                      day_of_week == "Sunday", "Weekends", weekdays)]
# weekdays1 <- c("Monday", "Tuesday", "Wednesday", "Thursday", "Friday")
# df$weekday <- factor((df$day_of_week %in% weekdays1), 
#                    levels = c(TRUE, FALSE), labels = c('Weekday', 'Weekend'), ordered = TRUE)
```

```{r cleanData, include=FALSE}
# Clean data ----
cleanDT <- rawDT
# removal of silly state of charge percentage values ----
#df$SoC_percent[df$SoC_percent > 100] <- NA
cleanDT <- cleanDT[SoC_percent > 100, SoC_percent := NA]
#df$SoC_percent[df$SoC_percent < 0] <- NA
cleanDT <- cleanDT[SoC_percent < 0, SoC_percent := NA]

# > removal of silly charge_power_kw values ----
# "...charging stations are being developed with capacities of 120kW in New Zealand"
# (Concept Consulting report)
#df$charge_power_kw[df$charge_power_kw > 120] <- NA
cleanDT <- cleanDT[charge_power_kw > 120, charge_power_kw := NA]

# > remove vehicles with all-zero charging values ----
# also removes those with very few observations
summaryDT <- cleanDT[, .(mean = mean(charge_power_kw), sd = sd(charge_power_kw), nObs = .N), keyby = .(dvID)]
includeDT <- summaryDT[mean != 0, .(dvID)] # just keep id variable (not the summary stats as well)
setkey(includeDT, dvID)
setkey(cleanDT, dvID)
cleanDT <- cleanDT[includeDT]

# set key (& order) to id & dateTime ----
# crucial for various calculations
setkey(cleanDT, id, dateTime)

# calculate time diff from 1 obs to the next ----
cleanDT <- cleanDT[, dateTimeDiff := dateTime - shift(dateTime), by = id]
```

```{r createChargeSequenceFlag, include=FALSE}
# Create charge flag ----
cleanDT <- cleanDT[, chargeFlag := "Not classified (what is this??)"]

cleanDT <- cleanDT[, chargeFlag := ifelse(charge_power_kw == 0, "Not charging (0 kW)", chargeFlag)]

cleanDT <- cleanDT[, chargeFlag := ifelse(shift(charge_power_kw, type = "lag") == 0 & # previous = 0
                                  charge_power_kw > 0 & # this one = charging
                                  shift(charge_power_kw, type = "lead") == 0,# next one is 0
                                "Single charge observation", chargeFlag), by = id] 

# test method 1: use 120 second threshold ----     
clean1DT <- cleanDT[, chargeFlag := ifelse(shift(charge_power_kw, type = "lag") == 0 & # previous = 0
                                  charge_power_kw > 0 & # this one = charging
                                  shift(charge_power_kw, type = "lead") > 0 & # next one also charging
                                    dateTimeDiff < 120, #  and within 2 minutes
                                "First charge obs in a seq", chargeFlag), by = id] 

clean1DT <- clean1DT[, chargeFlag := ifelse(shift(charge_power_kw, type = "lag") > 0 &  # previous = charging and
                                            shift(dateTimeDiff, type = "lag") < 120 & # within 2 minutes
                                            charge_power_kw > 0 & # this one = charging
                                            shift(charge_power_kw, type = "lead") > 0,  # next one also charging
                                          "Charging in a seq", chargeFlag), by = id] 

clean1DT <- clean1DT[, chargeFlag := ifelse(shift(charge_power_kw, type = "lag") > 0 & # previous = charging
                                            shift(dateTimeDiff, type = "lag") < 120 & # within 2 minutes
                                            charge_power_kw > 0 & # this one = charging
                                            shift(charge_power_kw, type = "lead") == 0, # next one not charging
                                "Last charge in a seq", chargeFlag), by = id] 

sequenceMethod1_T <- table(clean1DT$chargeFlag, clean1DT$chargeType, useNA = "always")

#cleanDT$chargeFlag <- ordered(cleanDT$chargeFlag, levels=c("first", "charging", "last"))

# test method 2: no 120 second threshold ----     
clean2DT <- cleanDT[, chargeFlag := ifelse(shift(charge_power_kw, type = "lag") == 0 & # previous = 0
                                  charge_power_kw > 0 & # this one = charging
                                  shift(charge_power_kw, type = "lead") > 0 , # next one also charging
                                    #dateTimeDiff < 120, #  and within 2 minutes
                                "First charge obs in a seq", chargeFlag), by = id] 

clean2DT <- clean2DT[, chargeFlag := ifelse(shift(charge_power_kw, type = "lag") > 0 &  # previous = charging and
                                            #shift(dateTimeDiff, type = "lag") < 120 & # within 2 minutes
                                            charge_power_kw > 0 & # this one = charging
                                            shift(charge_power_kw, type = "lead") > 0,  # next one also charging
                                          "Charging in a seq", chargeFlag), by = id] 

clean2DT <- clean2DT[, chargeFlag := ifelse(shift(charge_power_kw, type = "lag") > 0 & # previous = charging
                                            #shift(dateTimeDiff, type = "lag") < 120 & # within 2 minutes
                                            charge_power_kw > 0 & # this one = charging
                                            shift(charge_power_kw, type = "lead") == 0, # next one not charging
                                "Last charge in a seq", chargeFlag), by = id] 

sequenceMethod2_T <- table(clean2DT$chargeFlag, clean2DT$chargeType, useNA = "always")


```


```{r setCleanData}
# applying the 120 second rule reduces the number categorised as it will not know what to do with:
# charge -> gap of > 120 secs -> charge <gap of > 120 secs -> charge
# for now we therefore do not use the 120 second rule (see annex #chargeFlagTest for reporting)

cleanDT <- clean2DT # use no threshold data

```

```{r getPairs, include=FALSE}
# events in a sequence should be of the same type
# but they might not be if our threshold method gets it wrong - e.g. the first (or last) appears fast but then it 
# trickles (or vice versa)

# Select first & last to get pairs (also used for durations) ----

firstLastDT <- cleanDT[chargeFlag %like% "First" | chargeFlag %like% "Last"]

# set endType to type of the next observation for all
# don't subset as it will just use the next 'First' which is not what we want
firstLastDT <- firstLastDT[,endType := shift(chargeType, type = "lead")]

# now set the endType to NA for the Last charge obs
firstLastDT <- firstLastDT[chargeFlag %like% "Last",endType := NA]

# set a flag if the charge type differs (doesn't catch mid-sequence differences but it's a start...) ----
firstLastDT <- firstLastDT[, chargeTypeError := ifelse(chargeType %like% "Fast" & endType %like% "Fast",
                                                       "OK: first = Fast, last = Fast",
                                                       NA)]
firstLastDT <- firstLastDT[, chargeTypeError := ifelse(chargeType %like% "Standard" & endType %like% "Standard",
                                                       "OK: first = Standard, last = Standard",
                                                       chargeTypeError)]
firstLastDT <- firstLastDT[, chargeTypeError := ifelse(chargeType %like% "Fast" & endType %like% "Standard",
                                                       "Error: first = Fast, last = Standard",
                                                       chargeTypeError)]
firstLastDT <- firstLastDT[, chargeTypeError := ifelse(chargeType %like% "Standard" & endType %like% "Fast",
                                                       "Error: first = Standard, last = Fast",
                                                       chargeTypeError)]

# check just using the first of the pairs ('Last' will be set to NA)
with(firstLastDT[chargeFlag %like% "First"], table(chargeTypeError, chargeType, useNA = "always"))

# default corrected ----
firstLastDT <- firstLastDT[, chargeTypeCorrected := chargeType]

# If any of them are fast, change
firstLastDT <- firstLastDT[, chargeTypeCorrected := ifelse(chargeTypeError == "Error: first = Standard, last = Fast" |
                                                         chargeTypeError == "Error: first = Fast, last = Standard",
                                                       "Fast charging",
                                                       chargeType)]

firstLastDT <- firstLastDT[, chargeTypeCorrected := factor(chargeTypeCorrected, levels = c('Not charging', 
                                                  'Standard charging', 
                                                  'Fast charging'))] # auto-sets the order

# test
with(firstLastDT[chargeFlag %like% "First"], table(chargeTypeCorrected, chargeType, useNA = "always"))

# re-calculate the duration as it was done using the sequence not the first & last ----
# relies on correct order
firstLastDT <- setkey(firstLastDT, dvID, dateTime)
# difftime(timeEnd, timeStart, units='mins')
firstLastDT <- firstLastDT[, pairDuration :=  difftime(shift(dateTime, type = "lead"), dateTime, units='mins'), by = id] # set all within id
firstLastDT <- firstLastDT[chargeFlag %like% "Last", pairDuration := NA] # removes for last


```


# Introduction

The New Zealand government has set a target of increasing the number of electric vehicles (EVs) in New Zealand to 64,000 by 2021 [@TranspowerNewZealand2017]. High penetration of EVs would cause EV recharging to contribute a substantial portion of total electricity load. A report prepared for lines companies Orion, Powerco and Unison by Concept Consulting Group entitled "Driving change - Issues and options to maximise the opportunities from large-scale electric vehicle uptake in New Zealand" predicts that if all current light private vehicles were electric, annual residential electricity consumption would increase by approximately 30%, whereas if all vehicles including trucks were electric, this would increase the total electricity consumption of New Zealand by approximately 41% [@ConceptConsulting2018]. 

New Zealand's total electricity demand varies throughout the day, with weekdays in particular having two distinct "peaks"; one in the morning, and one in the evening [@TranspowerNZ2015]. Providing the electricity to meet these demand peaks is a costly and inefficient process [@Khan2018]. Concurrent electric vehicle charging, especially in the early evening when many motorists return home [@speidel_driving_2014,@langbroek_when_2017], would have the potential to negatively impact the operation of the grid through drastically increasing peak loads [@Azadfar2015,@langbroek_when_2017], leading to an increased cost of electricity due to the requirement of expensive upgrades to the electricity grid [@Stephenson2017].

The Concept Consulting report considers different methods of EV charging in its models. The assumption that most drivers would begin charging immediately after returning home is referred to as "passive" charging, while charging that is programmed (either by the driver or by an external entity) to occur during off-peak periods is referred to as "smart". The modelling undertaken in the Concept Consulting report suggests that under a scenario whereby 57% of the current private vehicle fleet were EVs (corresponding to one EV per household), passive charging would cause an increase of peak electricity demand of approximately 3,000MW, whereas if all were charged in a "smart" fashion, there would be no increase in peak demand.

This report extends the work done by Concept Consulting, but utilises actual data collected from electric vehicles, as opposed to using models based on the current New Zealand transport sector. The intention of the report is to provide further insight into the potential effects on the New Zealand electricity grid that may occur with a dramatic increase in EVs, so that these may be planned for and mitigated. It is also inspired by the [UK Department of Transport 2018 statistical report ](https://assets.publishing.service.gov.uk/government/uploads/system/uploads/attachment_data/file/764270/electric-chargepoint-analysis-2017-domestics.pdf) [@Eyers2018].


# Data{#data}

## Background{#background}

The data used has been provided by 'Flip the Fleet', a community organisation that hopes to increase uptake of electric vehicles in New Zealand. Flip the Fleet have been collecting data on electric vehicle usage patterns, via Exact IOT Limited's [blackbox recorder](https://flipthefleet.org/ev-black-box/), a small electronic  device that connects to the vehicle's internal computer and sends detailed data about the battery health, power demand, charging rate, speed and other performance information to a secure database.

The subset of this data provided to the University of Otago was collected from `r data.table::uniqueN(rawDT$id)` domestic electric vehicles monitored from `r format(min(rawDT$date), format = "%B %Y")` to `r format(max(rawDT$date), format = "%B %Y")`. The data consisted of `r prettyNum(nrow(rawDT), big.mark = ",")` 1 minute interval observations of timestamped odometer readings (in km) together with measurements of charging power (kW) and battery charge state (% charged) linked to a unique anonymised vehicle identifier.

There are a number of important limitations to this data:

 * measurement of observations only occurs when the car is switched on and/or plugged in and charging. As a result no data will be collected when the EV is switched off. This means that there are large non-erroneous 'gaps' in the data which represent 'no charging' (and also 'no driving') but which are not included as '0 power demand' in the analyses since to do so would require imputation of a very large number of missing time stamps for each vehicle. This means we are only really able to analyse power demand profiles for vehicles that were charging, _not for all vehicles in all time periods_;
 * data upload relied on mobile 3G data signal and the extent to which gaps in the data are due to data upload errors rather than vehicle non-use (as above) is currently unclear;
 * these vehicles are driven by 'early adopters' who have opted to install the measuring devices in order to collect their vehicle usage data. As a result the data may not be representative of the usage patterns of current or future EV drivers [@rezvani_advances_2015,@li_review_2017].

Even though the use of an anonymised vehicle identifier should prevent the identification of the vehicles in the sample, the fine-grained temporal nature of the data and the relatively small population of EV owners from whom the sample is drawn (Flip The Fleet members) means that the data cannot be publicly released.

## Initial cleaning{#cleaning}

```{r initialDataChecks}
# make a plot of the number of EVs seen per day/hour
rawDT <- rawDT[, r_dateTime := lubridate::as_datetime(paste0(date, time))]
plotDT <- rawDT[, .(nEVs = uniqueN(id),
                    nObs = .N), keyby = .(time15m = hms::trunc_hms(time, 15*60),
                                                   date = lubridate::date(r_dateTime))]
plotDT <- plotDT[, nObsPerEV := nObs/nEVs]
```

Figure \@ref(fig:initialDataChecksPlot) shows the number of unique EVs observed by time of day and date. As we can see the early part of the sample is sparse and indeed the maximum number of EVs observed in any 15 minute time period was only `r max(plotDT$nEVs)` out of a possible total of `r data.table::uniqueN(rawDT$id)`. While this will not affect some analyses, it is likely to introduce error and small sample effects to summary analyses (e.g. means) or month by month analyses. In some sections the analysis will therefore be restricted to the data from September to January.

In addition Table \@ref(fig:initialDataChecksPlot) shows that a small number of EVs have very few observations, in some cases not extending beyond 1 day (shown as 0 days observed). 

```{r initialDataChecksPlot, fig.cap="Number of unique EVs observed by time of day and date"}
ggplot2::ggplot(plotDT, aes(x = date, y = time15m, alpha = nEVs)) +
  geom_tile() +
  #scale_alpha(breaks = c(0,5,10,15,20)) +
  labs(x = "Date",
       y = "Time of Day",
       caption = paste0("Data: All received data",
                        "\n nEVs = Unique EVs observed")
       )

# ggplot2::ggplot(plotDT, aes(x = date, y = time15m, alpha = nObs)) +
#   geom_tile()
# 
# ggplot2::ggplot(plotDT, aes(x = date, y = time15m, alpha = nObsPerEV)) +
#   geom_tile()

# make a list of vehicles with start & end dates

vehicleIDsDT <- rawDT[, .(nObs = .N,
                          startTime = min(r_dateTime),
                          endTime = max(r_dateTime),
                          meanWhCharging = mean(charge_power_kw),
                          maxWhCharging = max(charge_power_kw)), keyby = .(id)]

vehicleIDsDT <- vehicleIDsDT[, nDaysObserved := as.Date(endTime) - as.Date(startTime)]

t <- head(vehicleIDsDT[order(nObs)],6)

kableExtra::kable(t, 
                  caption = "Number of observations and start/end dates for vehicles (6 most scarce)") %>%
  kable_styling()
```

Further, as Table \@ref(fig:initialDataChecksPlot) also indicates, there were several (`r nrow(summaryDT) - nrow(includeDT)`) vehicles that had no recorded charging observations. These were discarded (which also discarded those with very few observations).

We then discarded:

 * `r nrow(rawDT[ charge_power_kw > 120])` instances of charging power greater than 120kW. These were considered anomalies and as these exceed the capacity of the highest charging stations currently available in New Zealand [@ConceptConsulting2018];
 * `r nrow(rawDT[SoC_percent > 100])` instances of battery state of charge observations of greater than 100%.

This left `r data.table::uniqueN(cleanDT$dvID)` remaining vehicles, and `r prettyNum(nrow(cleanDT), big.mark = ",")` observations as shown in Table \@ref(tab:finalTable).

```{r finalTable}
t <- addmargins(table(cleanDT$chargeType, cleanDT$weekday, useNA = "always"))

kableExtra::kable(t, 
                  caption = "Number of observations by charge flag (final cleaned data)") %>%
  kable_styling()
```

 
## Definitions and preparation{#definitions}

### Charge type{#chargeType}

Charging data has been broadly separated into two separate categories, 'Standard' and 'Fast'. Standard charging is defined to be when the charger is reading less than 7kW - this is considered the upper limit of ordinary home charging without an expensive wiring upgrade [@ConceptConsulting2018]. Fast charging is all charging equal to or greater than 7kW, and would likely occur at designated and purpose-built public charging stations.

> It should be noted that this method is not always accurate since we can identify apparent sequences of charging which start at > 7kW and decline to < 7kW over a relatively short period. In this circumstance the first observation will be correctly classified as 'Fast' but the lower observations, which we assume are lower power trickle 'top-up' at the end of a fast charge will be incorrectly classified as 'Standard' (see \@ref(processedCheck)). This is clarified in Section \@ref(duration) where we use the first observation in a sequence to denote fast/standard but has yet to be resolved in other sections. As a result we may currently be _under-estimating_ the number of fast charge observations and _over-estimating_ the mean power demand of standard charges. Future work will resolve this potential misclassification error.

```{r testErrors}
nErrors <- nrow(firstLastDT[chargeTypeError %like% "Error"])
```

As an example, we know that there are `r nErrors` sequences of charging events (out of a total of `r nrow(firstLastDT)`) where the first and last charge types do not match. Of these `r nrow(firstLastDT[chargeTypeError %like% "first = Fast"])` were pairs where the first charging observation was 'Fast' and the last classified at 'Standard'. 

Figure \@ref(fig:obsPower) shows the distribution of observed charging kW demand by inferred charge type without correcting for potential mis-classifications. Setting aside the small number of potential misclassifications noted above, the plot confirms the validity of our definition and shows that fast charges were relatively rare in the dataset. Fast charges have two distinct power demand 'peaks' at ~22kW and ~45kW while the far more common standard charging was mostly concentrated around 1.8kW and 3kW, with a smaller concentration around 6kW.

```{r obsPower, fig.cap="Observed power demand distribution by charge type where charging observed"}

plotDT <- cleanDT[!(chargeType %like% "Not charging")]

genCap <- paste0("Data source: Flip The Fleet",
                 "\n All charging observations",
                 "\n n EVs: ", uniqueN(plotDT$dvID), ", n observations: ", nrow(plotDT),
                        "\n Period: ", min(plotDT$date), " - ", max(plotDT$date)
)

p <- ggplot2::ggplot(plotDT, aes(x = charge_power_kw, fill = chargeType)) +
  geom_histogram(binwidth = 0.1) +
  facet_wrap(. ~ chargeType, scales = "free")
p + labs(y = "Charging observations",
       x = "Power (kW)",
       caption = genCap) +
  guides(fill = guide_legend(title = "Inferred charge type:")) +
  scale_fill_manual(values=cbgPalette) + # use colour-blind friendly palette
  theme(legend.position = "bottom")
```

### Charge sequences{#codeSequences}

In order to determine charging durations, we need to identify observations which are the start and end of charging sequences. We use the following logic to do this:

 * rows were coded as "charging begins" if the charging power was greater than zero and the previous and following row's charging power were (respectively) equal to zero and greater than zero;
 * rows were coded as "charge ends" if the charging power was greater than zero and the previous and following row's charging power were (respectively) greater than zero and equal to zero;
 * rows were coded as "charge in a sequence" if charging power > 0 and the observations either side were also > 0
 * rows were coded as "single charge events" if charging power > 0 but the observations either side were 0.

```{r seqCodeTable}
# best not to create new data.tables if we don't need to - easy just to filter/subset
# use the firstLast dt
nChBegins <- nrow(firstLastDT[chargeFlag %like% "First"])
nChEnds <- nrow(firstLastDT[chargeFlag %like% "Last"])

t <- table(cleanDT$chargeFlag, clean2DT$chargeType, useNA = "always")

kableExtra::kable(addmargins(t), caption = "Charge sequence coding results") %>%
  kable_styling()
```

Table \@ref(tab:seqCodeTable) shows the results of this coding for all clean observations. As we can see very few observations were not coded using this scheme. As shown in Section \@ref(chargeFlagTest) an alternative method which added a 120 second maximim threshold to sequences of observations was also tested but not used as it failed to identify sparse sequences of charging events.

Using this method we obtained `r prettyNum(nChBegins, big.mark = ",")` instances of charging starting, and `r prettyNum(nChEnds, big.mark = ",")` instances of charge ending. The additional `r nChEnds - nChBegins` instances of the charge ending than there are of the charge beginning may be due to the first instance of data collection occurring during mid-charge for some vehicles. 

The charge duration was then calculated as being the time duration between each pair of "first charge" and "last charge" observations

Figure \@ref(fig:durationHist) shows the overall distribution of all charging sequences. Clearly there are very small and a few very large values for both charging types.

```{r durationHist, fig.cap="Duration of charging sequences"}

plotDT <- firstLastDT[chargeFlag %like% "First"]

genCap <- paste0("Data source: Flip The Fleet",
                 "\n'First charge' observations, corrected charge type",
                 "\n n EVs: ", uniqueN(plotDT$dvID), ", n observations: ", nrow(plotDT),
                        "\n Period: ", min(plotDT$date), " - ", max(plotDT$date)
)
                        
ggplot2::ggplot(plotDT, 
                aes(x = pairDuration)) +
  geom_histogram(binwidth = 10) +
  facet_wrap(chargeTypeCorrected ~ ., scales = "free") +
    labs(x = "Minutes", 
       caption = genCap)
```

Table \@ref(tab:durationDescTable) shows the overall distributions and indicates the extent to which the means are skewed by the very small and a few very large values shown in Figure \@ref(fig:durationHist).

```{r durationDescTable}
t <- firstLastDT[chargeFlag %like% "First" & !is.na(pairDuration), 
                 .(N = .N,
                   mean = mean(pairDuration),
                   median = median(pairDuration),
                   min = min(pairDuration),
                   max = max(pairDuration)), 
                 keyby = .(chargeTypeCorrected)]
kableExtra::kable(t, 
                  caption = "Duration of all charge sequences by charge type", digits = 2) %>%
  kable_styling()
```

Figure \@ref(fig:shortDuration) shows the distribution of very short charging sequences. As we can see these appear to be generally less than 8 minutes in length for Standard Charges.

```{r shortDuration, fig.cap="Duration of charging sequences < 15 minutes"}
plotDT <- firstLastDT[chargeFlag %like% "First" & pairDuration < 15]

genCap <- paste0("Data source: Flip The Fleet",
                 "\n 'First charge' observations, corrected charge type",
                 "\n n EVs: ", uniqueN(plotDT$dvID), ", n observations: ", nrow(plotDT),
                 "\n Period: ", min(plotDT$date), " - ", max(plotDT$date)
                 )

ggplot2::ggplot(plotDT, 
                aes(x = pairDuration)) +
  geom_histogram(binwidth = 1) +
  facet_grid(chargeTypeCorrected ~ ., scales = "free") +
  labs(x = "Minutes", 
       caption = genCap
       )
```

Table \@ref(tab:durationDescTableReduced) shows the same descriptive statistics but for all sequences of greater than 8 minute duration. Now we can see that the mean and median durations for both Standard and Fast Charge sequences are closer.

```{r durationDescTableReduced}
t <- firstLastDT[chargeFlag %like% "First" & pairDuration > 8, 
                 .(N = .N,
                   mean = mean(pairDuration),
                   median = median(pairDuration),
                   min = min(pairDuration),
                   max = max(pairDuration)), 
                 keyby = .(chargeTypeCorrected)]
kableExtra::kable(t, 
                  caption = "Duration of charge sequences > 8 minutes by charge type (minutes)", digits = 2) %>%
  kable_styling()
```


Manual inspection of the data showed that these short-duration charging "events" generally occurred near the end of a longer-duration charging sequence It appeared that once the vehicle had reached its highest state of charge, charging would intermittently stop and start again. This is probably due to the behaviour of the charger once the battery was almost full. 
In addition to the myriad "short" charging duration values, a small number of unreasonably long charging durations (longer than 100 hours for standard charging or longer than 14 hours for fast charging) were calculated. As these exceeded the expected charge durations of the most high capacity vehicles currently available, they were also assumed to be anomalies. The analyses in Section \@ref(duration) below was therefore made with the following charge events excluded from the data:

 * duration > 6000 minutes (`r nrow(firstLastDT[pairDuration > 6000])` observations)
 * duration < 8 minutes for standard charging (`r nrow(firstLastDT[pairDuration < 8 & chargeTypeCorrected %like% "Standard"])` observations - noting that some of these may be short low power 'fast charge' events as discussed in Section \@ref(#chargeType))
 * duration > 840 minutes for fast charging (`r nrow(firstLastDT[pairDuration > 840 & chargeTypeCorrected %like% "Fast"])` observations)


```{r removeBigAndSmallDurations}
# Remove overly large values
#table(firstLastDT$chargeFlag)
firstCleanDT <- firstLastDT[pairDuration < 6000] # Last have pairDuration of NA so this removes them automatically (we don't need them any more)
#table(firstCleanDT$chargeFlag)

# ATTN BEN do we do the following here or disply the plots below that depend on the small values and then remove them for further analysis?

# Remove standard charges of duration less than 8 mins
firstCleanDT <- firstCleanDT[!(firstCleanDT$pairDuration < 8 & 
                                         firstCleanDT$chargeTypeCorrected %like% "Standard")]

# Remove fast charge of duration greater than 14 hours
firstCleanDT <- firstCleanDT[!(firstCleanDT$pairDuration > 840 & 
                                         firstCleanDT$chargeTypeCorrected %like% "Fast charging")]
```

Figure \@ref(fig:longDuration) and \@ref(tab:longDuration) shows the distribution of charging sequences with the excessively long or short events removed. These charging durations appear more reasonable when considering standard battery capacities and charging powers. 

```{r longDuration, fig.cap="Duration of charging sequences with unreasonably long or short values removed"}

genCap <- paste0("Data source: Flip The Fleet",
                 "\n 'First charge' observations, corrected charge type",
                 "\n n EVs: ", uniqueN(firstCleanDT$dvID), ", n observations: ", nrow(firstCleanDT),
                 "\n Period: ", min(firstCleanDT$date), " - ", max(firstCleanDT$date)
                 )

ggplot2::ggplot(firstCleanDT, 
                aes(x = pairDuration)) +
  geom_histogram(binwidth = 5) +
  facet_wrap(chargeTypeCorrected ~ ., scales = "free") +
  labs(x = "Minutes", caption = genCap)
#ggsave("plots/charge_duration_histogram_extremes_removed.png")

t <- firstCleanDT[chargeFlag %like% "First", 
                 .(N = .N,
                   mean = mean(pairDuration),
                   median = median(pairDuration),
                   min = min(pairDuration),
                   max = max(pairDuration)), 
                 keyby = .(chargeTypeCorrected)]
kableExtra::kable(t, 
                  caption = "Duration of charge sequences, final duration data (minutes)", digits = 2) %>%
  kable_styling()


```


```{r keyFindings}
# calculate these here for re-use
# these do not use the corrected chargeType
dt <- cleanDT[chargeType %like% "Standard" & charge_power_kw > 0]
stdMedian <- median(dt$charge_power_kw, na.rm = TRUE)
stdMean <- mean(dt$charge_power_kw, na.rm = TRUE)

dt <- cleanDT[chargeType %like% "Fast" & charge_power_kw > 0]
fastMedian <- median(dt$charge_power_kw, na.rm = TRUE)
fastMean <- mean(dt$charge_power_kw, na.rm = TRUE)

# these do use the corrected chargeType
dt <- firstCleanDT[chargeTypeCorrected %like% "Fast"]
fastDurMedian <- median(dt$pairDuration, na.rm = TRUE)
fastDurMean <- mean(dt$pairDuration, na.rm = TRUE)

dt <- firstCleanDT[chargeTypeCorrected %like% "Standard"]
standardDurMedian <- median(dt$pairDuration, na.rm = TRUE)
standardDurMean <- mean(dt$pairDuration, na.rm = TRUE)
```


# Time of charging

It has been suggested that EV charging is more likely to occur in the early evening when drivers return from daily commutes or school pick-ups [@langbroek_when_2017]. Figure \@ref(fig:chargeBeginsTime) uses a density plot to represent the proportion of charging and non-charging observations at different times of day by weekday vs weekends. The plot clearly shows non-charging during day-time use and also shows a bi-model distribution for fast charging (non-corrected categorisation). Standard charging also shows a bi-modal distribution with a peak around 22:00 on weekdays and another at 01:00 presumably indicating the use of timed or 'smart' charging or trickle events.

```{r chargeTime, fig.cap="Density plot of charging start times during weekdays"}
plotDT <- cleanDT

genCap <- paste0("Data source: Flip The Fleet",
                 "\n All observations",
                 "\n n EVs: ", uniqueN(plotDT$dvID), ", n observations: ", nrow(plotDT),
                        "\n Period: ", min(plotDT$date), " - ", max(plotDT$date)
)

p <- ggplot(plotDT, aes(x = as.POSIXct(qHour), fill = chargeType)) + # we have to force as.POSIXct if we want to use date_labels
  geom_density(alpha = 0.3) +
  theme(legend.position = "bottom") +
  facet_grid(weekdays ~ .)

p + labs(x = "Time", fill = "Charge type", 
         caption = genCap) +
  scale_x_datetime(date_labels = "%H:%M", date_breaks = "2 hours")

# can't add peak demand period annotations very easily to a density plot (need ymax/ymin)
#ggsave("plots/charge_time_weekday.png")

```

These patterns are also visible in Figure \@ref(fig:chargeTime) which shows the distribution of observed charging events by time of day and day of the week. 

```{r chargeTimeDoW, fig.cap="Count of observed charging events by type, day of week and time"}
# this is all charging observations not just the 'starts'
plotDT <- cleanDT[charge_power_kw > 0, .(count = .N,
                                         nCars = uniqueN(dvID)), keyby = .(qHour, day_of_week, chargeType)]

# make a weekend facet label
plotDT <- plotDT[, weekEnd := "Weekend"]
plotDT <- plotDT[day_of_week != "Saturday" & day_of_week != "Sunday", weekEnd := "Week day"]

capDT <- cleanDT[charge_power_kw > 0]
genCap <- paste0("Data source: Flip The Fleet",
                 "\n All charging observations",
                 "\n n EVs: ", uniqueN(capDT$dvID), ", n observations: ", nrow(capDT),
                        "\n Period: ", min(capDT$date), " - ", max(capDT$date)
)

p <- ggplot2::ggplot(plotDT, aes(x = as.POSIXct(qHour), y = count/nCars, colour = day_of_week)) +
  geom_point() + # points better esp for the fast charges
  facet_grid(chargeType~weekEnd, scales = "free_y")
  
p + theme(axis.text.x = element_text(angle = 90, hjust = 1)) + 
  labs(x = "Time of day",
       y = "Observations per car",
       caption = genCap) +
  guides(colour = guide_legend(title = "Day of week:")) +
  scale_colour_manual(values=cbgPalette) + # use colour-blind friendly palette
  theme(legend.position = "bottom") +
  scale_x_datetime(date_labels = "%H:%M", date_breaks = "2 hours")
```

This figure indicates that the greatest frequency of standard charging events occur between the hours of 8pm and 8am, with very low occurrences of charging during morning and evening grid peaks. Fast charging on the other hand is a day-time activity on both weekdays and weekends.

To make the patterns of 'initial charging' clearer, we use just the 'first' charge observation in a pair (see above) and exclude automatic battery 'top-ups' (refer to Section \@ref(SoC)) by also filtering out any data where a charging observation begins while the state of charge is greater than 90%. Having done so, Figure \@ref(fig:chargeBeginsTime) uses a density plot to represent the proportion of charging events that begin at different times of the day on weekdays vs weekends for standard and fast charging (corrected classification).

```{r chargeBeginsTime, fig.cap="Density plot of charging start times during weekdays where state of charge < 90%"}
#plotDT <- chargingDT[chargeFlag == "first" & SoC_percent < 90]
# use the cleaned firstLast dt
plotDT <- firstCleanDT[SoC_percent < 90] # should be the same

genCap <- paste0("Data source: Flip The Fleet",
                 "\n All charging observations where state of charge < 90%",
                 "\n n EVs: ", uniqueN(plotDT$dvID), ", n observations: ", nrow(plotDT),
                        "\n Period: ", min(plotDT$date), " - ", max(plotDT$date)
)

p <- ggplot(plotDT, aes(x = as.POSIXct(qHour), fill = chargeTypeCorrected)) + # we have to force as.POSIXct if we want to use date_labels
  geom_density(alpha = 0.3) +
  theme(legend.position = "bottom") +
  facet_grid(weekdays ~ .)

p + labs(x = "Time", fill = "Charge type", caption = genCap) +
  scale_x_datetime(date_labels = "%H:%M", date_breaks = "2 hours")

# can't add peak demand period annotations very easily to a density plot (need ymax/ymin)
#ggsave("plots/time_charging_begins_weekday.png")

```

As we can see, standard charging sequences (as opposed to single observations) have a noticeably different profile to charging patterns for fast charges. It suggests that the majority of standard charging events start at 22:00 and run overnight at home, and perhaps use the more powerful public charge points to top up during the day. However the plot also shows that this is not universal with a reasonable proportion of charging events starting earlier in the day, including during the NZ [peak demand periods](https://www.electrickiwi.co.nz/hour-of-power) of 07:00 - 09:00 and 17:00 - 21:00.

Standard charging events were most likely to begin around 10pm during both weekdays and weekends. As it seems unlikely that this is due to vehicle drivers returning home at this hour, this effect may be due to drivers setting the charger on a timer to take advantage of cheaper "off-peak" electricity times, which frequently begin around 10pm.

Fast charging events were most likely to begin at 11:30am on weekdays and 1pm during weekends.  

# Patterns of power demand

Given this distribution of charging events, it is important to understand their magnitude to understand the potential effect on the electricity network. Although we are hampered by the lack of 'no charge' data when the EV is not connected to the charger and switched off, this section analyses the patterns of power demand where charging is observed. Clearly this does not provide overall sample mean power demand which would include charging, non-charging _and_ non-use observations.

```{r stdChargeSizing}
stdQT <- quantile(cleanDT[charge_power_kw > 0 & chargeType %like% "Standard"]$charge_power_kw)
fastQT <- quantile(cleanDT[charge_power_kw > 0 & chargeType %like% "Fast"]$charge_power_kw)
```

Overall 75% of standard charging observations were `r round(stdQT[[2]],2)` kW or more but the figure was `r round(fastQT[[2]],2)` kW or more for fast charging.

```{r makePowerPlotDT}
dataDT <- cleanDT[charge_power_kw > 0 & date > as.Date("2018-09-01")]
plotDT <- dataDT[, .(meankW = mean(charge_power_kw),
                 mediankW = median(charge_power_kw),
                 sdkW = sd(charge_power_kw),
                 nEVs = uniqueN(dvID),
                 nDays = uniqueN(date),
                 nObs = .N), keyby = .(weekdays, qHour, chargeType)]
```

Figure \@ref(fig:meanChargeByTimeStd) shows the mean power demand for standard charging observations by time of day and weekdays vs weekends for the charging data collected after `r format(min(dataDT$date), format = "%B %Y")` to ensure maximum sample size (see Section \@ref(cleaning)). The plot uses transparency to indicate the number of EVs contributing to each of the mean calculations to give a guide to their reliability. Dots with stronger colours indicate means calculated from a larger number of EVs and, given the data gaps noted in Section \@ref(background), this indicates patterns which are generally shared across more EVs.

This plot appears to show that there are three peaks in standard charging, one at 10:00, one at 18:00 (possibly based on fewer EVs) and one after midnight on weekdays. There are also noticeable 07:00 and 16:00 charging blips. On the other hand at weekends the daytime peak shifts to 14:00. Thus, while our previous analysis suggested that charging events were more likely to start later in the evening, the power demand of earlier charging events may actually be relatively high and co-incide with exisitng peak demand periods. 

```{r meanChargeByTimeStd, fig.cap="Mean charging power demand (kW) by time of day"}
amPeakStart <- hms::as.hms("07:00:00")
amPeakEnd <- hms::as.hms("09:00:00")
pmPeakStart <- hms::as.hms("17:00:00") # see https://www.electrickiwi.co.nz/hour-of-power
pmPeakEnd <- hms::as.hms("21:00:00") # see https://www.electrickiwi.co.nz/hour-of-power

rectAlpha <- 0.1
vLineAlpha <- 0.4
vLineCol <- "#0072B2" # http://www.cookbook-r.com/Graphs/Colors_(ggplot2)/#a-colorblind-friendly-palette
myTextSize <- 3

addPeaks <- function(p){
  # takes a plot, assumes qHour is hms, adds peak period annotations
  # assumes you've set yMin & yMax already
  # breaks with facet_grid, scales = "free" so you have to build seperate plots if you want to do that
  # there is a complex solution (https://stackoverflow.com/questions/27898651/get-scales-range-of-facets-scales-free) but...
  p <- p + annotate("rect", xmin = amPeakStart,
             xmax = amPeakEnd, 
             ymin = yMin, ymax = yMax, 
             alpha = rectAlpha, fill = vLineCol)
  p <- p + annotate("rect", xmin = pmPeakStart,
             xmax = pmPeakEnd, 
             ymin = yMin, ymax = yMax, 
             alpha = rectAlpha, fill = vLineCol)
  return(p)
}

dt <- dataDT[chargeType %like% "Standard"]
genCap <- paste0("Data source: Flip The Fleet",
                 "\n All standard charging observations",
                 "\n n EVs: ", uniqueN(dt$dvID), ", n observations: ", nrow(dt),
                 "\n Period: ", min(dt$date), " - ", max(dt$date),
                 "\n Peak periods shaded"
)

p <- ggplot2::ggplot(plotDT[chargeType %like% "Standard"], aes(x = qHour, y = meankW, colour = weekdays, alpha = nEVs)) +
  geom_point() +
  scale_colour_manual(values=cbbPalette) + # use colour-blind friendly palette
  #facet_grid(chargeType ~ ., scales = "free") + # 
  labs(x = "Time of day",
       y = "Mean kW" ,
       caption = genCap)

yMin <- min(plotDT[chargeType %like% "Standard"]$meankW)
yMax <- max(plotDT[chargeType %like% "Standard"]$meankW)
addPeaks(p)
```

Fast charging however has no detectable pattern other than a clear increase in density during weekday daytimes (Figure \@ref(fig:meanChargeByTimeFast)).

```{r meanChargeByTimeFast, fig.cap="Mean charging power demand (kW) by time of day"}


dt <- dataDT[chargeType %like% "Fast"]
genCap <- paste0("Data source: Flip The Fleet",
                 "\n All fast charging observations",
                 "\n n EVs: ", uniqueN(dt$dvID), ", n observations: ", nrow(dt),
                 "\n Period: ", min(dt$date), " - ", max(dt$date),
                 "\n Peak periods shaded"
)

p <- ggplot2::ggplot(plotDT[chargeType %like% "Fast"], aes(x = qHour, colour = weekdays, alpha = nEVs)) +
  geom_point(aes(y = meankW)) +
  scale_colour_manual(values=cbbPalette) + # use colour-blind friendly palette
  #facet_grid(chargeType ~ ., scales = "free") + # 
  labs(x = "Time of day",
       y = "Mean kW" ,
       caption = genCap)

yMin <- min(plotDT[chargeType %like% "Fast"]$meankW)
yMax <- max(plotDT[chargeType %like% "Fast"]$meankW)
addPeaks(p)
```

It is possible that the 'standard charge' day-time peak is skewed by mis-classified short low power 'fast charge' observations (see Section \@ref(#chargeType)). Figure \@ref(fig:medianChargeByTime) attempts to allow for this misclassification by plotting the median rather than the mean. The plot more clearly shows the 10:00 weekday spike which, if we assume that the mis-classified 'fast charges' will be skewing the standard charge mean value upwards, is likely to be due to mis-classified 'fast charging'. However the 18:00 peak persists as does the 14:00 weekend peak while overnight charging levels are relatively stable as we would expect from \@ref(fig:meanChargeByTimeStd).  

```{r medianChargeByTime, fig.cap="Median charging power demand (kW) by time of day"}

dt <- dataDT[chargeType %like% "Standard"]
genCap <- paste0("Data source: Flip The Fleet",
                 "\n All Standard charging observations",
                 "\n n EVs: ", uniqueN(dt$dvID), ", n observations: ", nrow(dt),
                 "\n Period: ", min(dt$date), " - ", max(dt$date),
                 "\n Peak periods shaded"
)

p <- ggplot2::ggplot(plotDT[chargeType %like% "Standard"], aes(x = qHour, colour = weekdays, alpha = nEVs)) +
  geom_point(aes(y = mediankW)) +
  #facet_grid(chargeType ~ ., scales = "free") +
  scale_colour_manual(values=cbbPalette) + # use colour-blind friendly palette
  labs(x = "Time of day",
       y = "Median kW" ,
       caption = genCap)

yMin <- min(plotDT[chargeType %like% "Standard"]$meankW)
yMax <- max(plotDT[chargeType %like% "Standard"]$meankW)
addPeaks(p)
```


Figure \@ref(fig:meanChargeByTimeMonth) repeats the median power-based analysis for 'Standard charging' but shows the results by month. While the sample size is probably too small to draw robust conclusions there appear to be differences between months with December showing few discernable peaks and September and January showing much lower daytime weekday charging. In addition, weekdays and weekends are much more similar in November and December.

```{r meanChargeByTimeMonth, fig.cap="Median charging power demand (kW) by time of day", fig.height=6}
dataDT <- cleanDT[charge_power_kw > 0 & date > as.Date("2018-09-01")]

plotDT <- dataDT[, .(meankW = mean(charge_power_kw),
                 mediankW = median(charge_power_kw),
                 sdkW = sd(charge_power_kw),
                 nEVs = uniqueN(dvID),
                 nDays = uniqueN(date),
                 nObs = .N), keyby = .(weekdays, qHour, chargeType, month)]

genCap <- paste0("Data source: Flip The Fleet",                  "All standard charging observations",
                 "\n n EVs: ", uniqueN(dataDT$dvID),
                 "\n n observations: ", nrow(dataDT),
                 "\n Period: ", min(dataDT$date), " - ", max(dataDT$date),
                 "\n Peak periods shaded"
)

p <- ggplot2::ggplot(plotDT[chargeType == "Standard charging"], aes(x = qHour, colour = weekdays, alpha = nEVs)) +
  geom_point(aes(y = mediankW)) +
  scale_colour_manual(values=cbbPalette) + # use colour-blind friendly palette
  facet_grid(month ~ .) +
  labs(x = "Time of day",
       y = "Median kW",
       caption = genCap)

yMin <- min(plotDT[chargeType %like% "Standard"]$meankW)
yMax <- max(plotDT[chargeType %like% "Standard"]$meankW)
addPeaks(p)
```

On face value the results suggest that EVs could be placing additional power demand on local and national networks during well-known periods of peak demand although this appears to vary by month for this small sample of EV owners. 

> Clearly this analysis should be revisited once the potential misclassification of 'fast' as 'standard' charging observations has been resolved and the 'missing' non-use (zero charging) observations have been imputed. 

# Charging duration {#duration}

This section analyses the duration of observed charging events to understand when longer charging sequences are likely to occur. Table \@ref(tab:meanDurationTable) shows the mean durations for all all charging events by event start time for standard charging durations greater than 8 minutes (see Section \@ref(codeSequences)) and all fast charging events for observations collected after `r format(min(firstCleanDT[date >= as.Date("2018-09-01")]$date), format = "%d %B %Y")`.

```{r meanDurationTable}
t <- firstCleanDT[date >= as.Date("2018-09-01"), .(mean = mean(pairDuration),
               median = median(pairDuration),
               min = round(min(pairDuration),2),
               max = round(max(pairDuration),2),
               sd = round(sd(pairDuration),2)), keyby = .(chargeTypeCorrected)]
kableExtra::kable(t, caption = "Mean duration of charge events by charge type (filtered data, corrected charge type)", digits = 2) %>%
  kable_styling()
```


```{r makeDurationTimeMean}

dataDT <- firstCleanDT[date >= as.Date("2018-09-01")]
plotDT <- dataDT[,
                      .(meanDuration = mean(pairDuration),
                        nEVs = uniqueN(dvID)),
                      keyby = .(qHour, chargeTypeCorrected, weekdays)]

t <- head(plotDT[meanDuration > 480][order(-meanDuration)])

kableExtra::kable(t, 
                  caption = "Mean duration of charge sequences (values > 480 minutes)", digits = 2) %>%
  kable_styling()

plotDT <- plotDT[meanDuration < 540] # cut at 540 (9 hours)
```

Figure \@ref(fig:durationTimeMean) plots the mean duration by time of day and weekday vs weekend and charge type. As before we use transparency to indicate the number of unique EVs contributing to the mean values and we have removed a small number of very large duration outliers (mean duration > 540 minutes or 9 hours) which appears to be based on just 1 or 2 EVs (see Table \@ref:(tab:makeDurationTimeMean)).

As we would expect, the plot shows that for standard charging mean 'forward' duration generally decreases from midnight, presumably as batteries are becoming fully charged through to 06:00 and then increases as the time of starting to charge increases through the day before trending downwards before midnight. Again, this confirms that charge events starting in or just after the evening peak demand period on both weekdays and weekends are likely to be longer, possibly reflecting the lower state of charge at this time of day (following use).

Duration of fast charge events by start time appear to be more randomly distributed, although very few events were recorded between midnight and 7am. This, along with the comparatively low number of recorded fast charge events indicated in Fig. \@ref(fig:obsPower) suggests that drivers utilize fast charging only "as necessary" to ensure they have enough battery capacity to complete their journey or when 'at work' or conducting some other mobility related task such as shopping.

```{r durationTimeMean, fig.cap="Mean duration (within quarter hours) by time of charging start"}
genCap <- paste0("Data source: Flip The Fleet",                  
                 "\n First charging observations in a sequence, corrected charge type",
                 "\n n EVs: ", uniqueN(dataDT$dvID), ", n observations: ", nrow(dataDT),
                 "\n Period: ", min(dataDT$date), " - ", max(dataDT$date),
                 "\n Peak periods shaded, smoothed fit line via LOESS regression"
)

p <- ggplot2::ggplot(plotDT, 
                aes(x = qHour, y = meanDuration, colour = chargeTypeCorrected, alpha = nEVs)) +
  theme(legend.position = "bottom", axis.text.x = element_text()) +
  geom_smooth() +
  geom_point() +
  facet_grid(weekdays ~ .) +
  labs(x = "Time of day charging sequence started",
       y = "Mean duration of charge (mins)", col = "",
       caption = genCap)

yMin <- min(plotDT$meanDuration)
yMax <- max(plotDT$meanDuration)
addPeaks(p)
```




# State of charge{#SoC}

The state of charge is the percentage of energy still available to be used in the battery. In future, electric vehicles may be able to discharge any remaining battery charge as electricity into the grid, a process known as vehicle to grid (V2G) energy transfer. This may allow electric vehicles to have a net beneficial effect on the grid, reducing the evening peaks by providing electricity to the home during this period, and then recharging later in the evening or early the next morning when peak demand has diminished.

This section provides an indication of the state of charge of electric vehicles upon charging, so that the potential of V2G technology can be assessed.

```{r SoCplot1, fig.cap= "Value of state of charge (all charging observations)"}
# use corrected first in sequence data

dataDT <- cleanDT[chargeFlag %like% "First"]
  
genCap <- paste0("Data source: Flip The Fleet",                  
                 "\n All charging observations",
                 "\n n EVs: ", uniqueN(dataDT$dvID), ", n observations: ", nrow(dataDT),
                 "\n Period: ", min(dataDT$date), " - ", max(dataDT$date)
)

p <- ggplot(dataDT, aes(x = SoC_percent)) + geom_histogram(bins = 20)
p + labs(x = "State of charge when charging begins (%)", caption = genCap) +
  facet_grid(chargeType ~ ., scales = "free")

```

As can be seen in Figure \@ref(fig:SoCplot1), using the cleaned complete observations data, the state of charge for the majority of standard charge observations is above 90%. This is most likely due to the manner in which the charger regularly turns off and on again near the end of the charging cycle as described in Section \@ref(cleaning).

Figure \@ref(fig:SoCplot2) shows the state of charge values for all charging events but with state of charge greater than 90% removed from the data for clarity. The figure indicates that many vehicles begin charging despite having greater than 50% charge remaining. This has clear implications for battery life management since continually top-up charging is known to substantially shorten the lifetime of EV batteries (XX ref needed XX). However it also indicates the potential to use the charge in the battery to feed into the grid, especially in the residential context.

```{r SoCplot2, fig.cap= "Value of state of charge (values > 90% removed)"}
plotDT <- cleanDT[chargeFlag %like% "First" & SoC_percent < 90]

genCap <- paste0("Data source: Flip The Fleet",                  
                 "\n All charging observations, state of charge < 90%",
                 "\n n EVs: ", uniqueN(plotDT$dvID), ", n observations: ", nrow(plotDT),
                 "\n Period: ", min(plotDT$date), " - ", max(plotDT$date)
)

p <- ggplot(plotDT, aes(x = SoC_percent)) + geom_histogram(bins = 20)
p + labs(x = "State of charge when charging begins (%)", caption = genCap) +
  facet_grid(chargeType ~ ., scales = "free")

```

Figure \@ref(fig:SoCplot3) repeats this analysis but uses the cleaned and corrected inferred start/end of charging sequence data instead of all charging observations. Figure \@ref(fig:SoCplot3) shows very similar distributions to the previous 'all-observations' plot (Figure \@ref(fig:SoCplot2)) and confirms that sequences of standard charging in particular most frequently start with battery state of charge over 50%. 

```{r SoCplot3, fig.cap= "Value of state of charge at beginning of charging sequence (chargeType corrected, values > 90% removed)"}
plotDT <- firstCleanDT[SoC_percent < 90]

genCap <- paste0("Data source: Flip The Fleet",
                 "\n First charging observation in a sequence, state of charge < 90%",
                 "\n n EVs: ", uniqueN(plotDT$dvID), ", n observations: ", nrow(plotDT),
                 "\n Period: ", min(plotDT$date), " - ", max(plotDT$date)
)

p <- ggplot(plotDT, aes(x = SoC_percent)) + geom_histogram(bins = 20)
p + labs(x = "State of charge when charging begins (%)", caption = genCap) +
  facet_grid(chargeTypeCorrected ~ ., scales = "free")

```


```{r SoCplotTiming, fig.cap= "Mean state of charge at beginning of charge sequence by time of day (chargeType corrected, values > 90% removed)"}

dataDT <- firstCleanDT[SoC_percent < 90]
plotDT <- dataDT[, .(meanChargePC = mean(SoC_percent),
                 nEVs = uniqueN(dvID)), keyby = .(qHour, weekdays, chargeTypeCorrected)]

genCap <- paste0("Data source: Flip The Fleet",
                 "First charging observations in a sequence, state of charge < 90%",
                 "\n n EVs: ", uniqueN(dataDT$dvID), "n observations: ", nrow(dataDT),
                 "\n Period: ", min(dataDT$date), " - ", max(dataDT$date),
                 "\n Peak periods shaded, smoothed fit line via LOESS regression"
)
p <- ggplot(plotDT, aes(x = qHour, y = meanChargePC, colour = weekdays, alpha = nEVs)) + 
  geom_smooth() +
  geom_point() +
  labs(y = "Mean state of charge when charging begins (%)",
         x = "Time of Day",
       caption = genCap) +
  facet_grid(chargeTypeCorrected ~ ., scales = "free")
yMin <- min(plotDT$meanChargePC)
yMax <- max(plotDT$meanChargePC)
addPeaks(p)

#ggsave("plots/SOC_Time_when_charging_begins.png")
```

Finally, Figure \@ref(fig:SoCplotTiming) shows the mean % charge by time of first charging observation in a sequence using the cleaned and corrected inferred start/end of charging sequence data. The plot suggests that this capacity may be relatively stable throughout the day albiet with slightly higher mean capacity around the morning peak as we would expect given over-night charging. It is unlikely that this early morning capacity would be willingly made available for V2G since the EV may be used in the near future although this may not always be the case. However it is interesting to note that mean capacity at start of charge in the evening peak period is still roughly 50% indicating relatively substantial power availability.

# Summary {#summary}
Based on a relatively small and probably non-representative sample of `r data.table::uniqueN(cleanDT$dvID)` domestic electric vehicles provided by our research partner [FlipTheFleet](https://flipthefleet.org/) and which were monitored from `r format(min(rawDT$date), format = "%B %Y")` to `r format(max(rawDT$date), format = "%B %Y")` we have found that:

```{r keyFindingsDuration}
# XXX run to here to rebuild data ----
# use cleaned first obs

meanDurationStd <- mean(firstCleanDT[chargeTypeCorrected %like% "Standard"]$pairDuration, na.rm = TRUE)
medianDurationStd <- median(firstCleanDT[chargeTypeCorrected %like% "Standard"]$pairDuration, na.rm = TRUE)

meanDurationFast <- mean(firstCleanDT[chargeTypeCorrected %like% "Fast"]$pairDuration, na.rm = TRUE)
medianDurationFast <- median(firstCleanDT[chargeTypeCorrected %like% "Fast"]$pairDuration, na.rm = TRUE)

# use clean data (charge type not corrected)
meanPowerStd <- round(mean(cleanDT[chargeType %like% "Standard", charge_power_kw]),2)
medianPowerStd <- round(median(cleanDT[chargeType %like% "Standard", charge_power_kw]),2)

meanPowerFast <- round(mean(cleanDT[chargeType %like% "Fast", charge_power_kw]),2)
medianPowerFast <- round(median(cleanDT[chargeType %like% "Fast", charge_power_kw]),2)
```

  * _Power supplied_: The median power supplied during a charging event coded as 'standard' was `r medianPowerStd` kW. The mean was slightly higher at `r meanPowerStd` kW. Charging observations coded as 'Fast' had a median of `r medianPowerStd` kW (mean = `r meanPowerStd` kW). Mean power when charging showed a complex temporal profile for weekday standard charging (Figure \@ref(fig:meanChargeByTimeStd)) with a peak of ~ 2.5kw at 10:00 and a second of the same value at around 18:00 with further peaks just after midnight. The inverse is seen on weekends with a charge peak during the middle of the day;
  * _Charging duration_: Charging durations tended to fall into one of two groups. Longer 'standard' charges had a median duration of `r medianDurationStd` minutes and a mean duration of `r meanDurationStd` minutes. High power 'Fast' charge events had a median duration of `r medianDurationFast` minutes and a mean duration of `r medianDurationFast` minutes;
  * _Time of day_: Standard charging events tended to be the most frequent around 22:00 on both weekdays and weekends, suggesting the drivers in our dataset utilise timers to take advantage of off-peak electricity although this is not universal with a substantial proportion of charging events starting earlier in the day and potentially at higher power levels (see above). Fast charging events tended to begin at 11:30am on weekdays and 1pm during weekends;
  * _State of charge_: As has been previously shown [@speidel_driving_2014], any drivers begin recharging with greater than 50% charge still remaining in the battery for both standard and fast charge events. This has clear implications both for the management of battery life and also for the potential for vehicle-to-grid power flows during peak demand periods where vehciles may be at or arriving home with substantial available charge.
  
In the data provided for this study, most charging occurs at home using either a 1.8kw or 3kW charger, and commonly occurs both in the evening peak period and through the night. In addition, many vehicles begin charging with significant battery capacity remaining, providing them with the ability to provide vehicle to grid energy transfer should that technology become widely available. 

These preliminary findings support recent modelling work [@ConceptConsulting2018] that suggests that any negative effects electric vehicles may have on the evening national electricity grid peaks should be mitigable through 'smart' charging methods. In addition, our analysis indicates that this may already be occurring to some extent in this sample of EV owners. If later adopters of electric vehicles can be induced to follow the same 'smart' charging patterns as those displayed in some of our data sample, it is likely that the effects that electric vehicles are otherwise likely to have on the electricity grid may be mitigated.

# Statistical Annex

```{r resetOptions}
# turn these back on for annex
knitr::opts_chunk$set(echo = TRUE)
knitr::opts_chunk$set(warning = TRUE) # for final tidy run
knitr::opts_chunk$set(message = TRUE) # for final tidy run
```

## Flip The Fleet data description

### Raw data

Data description for original data supplied (before processing or filtering).

```{r ftfRawDataSkim}
skimr::skim(rawDF)
```

### Processed and cleaned data{#processedCheck}

Data description for cleaned data (all observations).

```{r ftfCleanDataSkim}
skimr::skim(cleanDT)
```

Data description for cleaned data (first observations in a charging sequence).

```{r ftfFirstCleanDataSkim}
skimr::skim(firstCleanDT)
```

## Coding checks

### Charge flag {#chargeFlagTest}

This is used to identify observations that form part of a sequence. The logic is given in Section \@ref(codeSequences). Here we show the results of applying an additional 120 second rule. In this case a sequence only exists where we have charging observations which have less than 120 seconds between them.

```{r checkChargeFlagMethods}

kableExtra::kable(sequenceMethod1_T, caption = "Charge sequence flags (120 second rule)") %>%
  kable_styling()

kableExtra::kable(sequenceMethod2_T, caption = "Charge sequence flags (no 120 second rule)") %>%
  kable_styling()
```

As we can see, applying the 120 second rule reduces the number of observations categorised as part of a sequence as it will not know what to do with:

 * charge -> gap of > 120 secs -> charge <gap of > 120 secs -> charge

For now we therefore do not use the 120 second rule.

```{r checkChargeFlags}
# Check chargeFlag ----
message("chargeFlag is used to classify charging events - check against charge type:")

t <- table(cleanDT$chargeFlag, cleanDT$chargeType, useNA = "always")
kableExtra::kable(t, caption = "chargeFlag errors (clean data)") %>%
  kable_styling()
message("There are a few observations that have chargeFlag = NA but are charging... why?")
```

We also test the patterns of charging that this classification produces. We do this first for 'standard' charging sequences and then for 'fast' charging sequences.

```{r debugSequences}
# debug sequences visually ----

# set start and end time in hms ----
firstLastDT <- firstLastDT[, startTime := as.hms(dateTime)]
firstLastDT <- firstLastDT[, endTime := as.hms(shift(dateTime, type = "lead"))]

# start & end charge rate ----
firstLastDT <- firstLastDT[, startChargekW := charge_power_kw]
firstLastDT <- firstLastDT[, endChargekW := shift(charge_power_kw, type = "lead")]

# start & end batter state
firstLastDT <- firstLastDT[, startSoC_pc := SoC_percent]
firstLastDT <- firstLastDT[, endSoC_pc := shift(SoC_percent, type = "lead")]

# calc duration so we can decide what to do where it is -ve - i.e. event spanned midnight ----
firstLastDT <- firstLastDT[, notDuration := difftime(endTime, startTime, units='mins'), by = id] # set all within id, if this is -ve then it spanned midnight
# fix # 1
firstLastDT <- firstLastDT[, endTimeTrunc := ifelse(notDuration < 0, 
                                                   hms::as.hms("23:59:00"),
                                                   endTime)] # this truncates charge periods that span midnight and ends then at midnight for clarity. Of course this makes a hash of early morning charging patterns... 

# charge rate & state of charge deltas ----
firstLastDT <- firstLastDT[, chargePowerDelta := endChargekW - charge_power_kw] # should be -ve where we start high and end low
firstLastDT <- firstLastDT[, SoC_pcDelta := endSoC_pc - startSoC_pc] # should be -ve where we start high and end low

```

Figure \@ref(fig:checkStdSequenceskW) plots the first and last charge observation in a sequence for all pairs and for all vehicles where events were classified as (corrected) 'standard' charges. The y value is charging rate (kW) at the start and end of the sequence. Colour (red end of the scale) is used to highlight pairs which show an 'odd' pattern - e.g. the charge rate increased.

```{r checkStdSequenceskW, fig.height=10, fig.cap="Standard charging (corrected) - rate of charge"}

# plotting function
makeSeqChargePlot <- function(dt, y = y, yend = yend, colour = colour){
  p <- ggplot2::ggplot(dt) +
    geom_segment(aes(x = as.POSIXct(startTime), 
                     xend = as.POSIXct(endTime), 
                     y = get(y), 
                     yend = get(yend), colour = get(colour))) +
    labs(x = "Sequence start time") + 
    theme(legend.position = "bottom") +
    scale_x_datetime(date_labels = "%H:%M", date_breaks = "4 hours") +
    facet_wrap(. ~ dvID)
  return(p)
}

dt <- firstLastDT[chargeTypeCorrected %like% "Standard" & 
                    #startChargekW < 5 & #use this to filter out the few that seem to have 6kW chargers (they could also be mis-coded 'fast' charging)
                    chargeFlag %like% "First" ,
                  .(startTime, endTime, endTimeTrunc, chargeTypeCorrected,startChargekW, endChargekW,
                    notDuration, chargePowerDelta, startSoC_pc, endSoC_pc, SoC_pcDelta, dvID)]

p <- makeSeqChargePlot(dt, y = "startChargekW", 
                       yend = "endChargekW", 
                       colour =  "chargePowerDelta") 
p <- p + 
  labs(y = "Charging rate (kW)",
       caption = "Standard charging (corrected) \n Pairs spanning midnight truncated at 23:59") +
  guides(colour = guide_legend(title = "Charge rate delta (kW)")) +
  scale_color_continuous(low = "green", high = "red") # highlight ones that went up
p
#ggsave("plots/standardChargePairs_kW_LineSegments.png", p, height = 10)
```

Figure \@ref(fig:checkStdSequencesSoC) uses the same approach but in this case the y value is charging rate (kW) at the start and end of the sequence. Colour (red end of the scale) is used to highlight pairs which show an 'odd' pattern - e.g. the battery state of charge decreased.

```{r checkStdSequencesSoC, fig.height=10, fig.cap="Standard charging (corrected) - state of charge"}
#dt <- dt[, SoC_pcDelta := SoC_pcDelta * -1] # invert so big drops become red in plot
p <- makeSeqChargePlot(dt, y = "startSoC_pc", 
                       yend = "endSoC_pc", 
                       colour =  "SoC_pcDelta")
p <- p + 
  labs(y = "State of charge (%)",
       caption = "Standard charging (corrected) \n Pairs spanning midnight truncated at 23:59") +
  guides(colour = guide_legend(title = "State of charge delta (%)")) +
  scale_color_continuous(low = "red", high = "green") # highlight ones that went down
p
#ggsave("plots/standardChargePairs_SoC_LineSegments.png", p, height = 10)

```

Figure \@ref(fig:checkFastSequenceskW) and Figure \@ref(fig:checkFastSequencesSoC) repeat these plots but for (corrected) 'fast' charge events.

```{r checkFastSequenceskW, fig.height=10, fig.cap="Fast charging (corrected) - rate of charge"}
dt <- firstLastDT[chargeTypeCorrected %like% "Fast" & 
                    #startChargekW < 5 & #use this to filter out the few that seem to have 6kW chargers (or they might be 'fast' charging too)
                    chargeFlag %like% "First",
                  .(startTime, endTime, endTimeTrunc, chargeTypeCorrected,startChargekW, endChargekW,
                    notDuration, chargePowerDelta, startSoC_pc, endSoC_pc, SoC_pcDelta, dvID)]

p <- makeSeqChargePlot(dt, y = "startChargekW", 
                       yend = "endChargekW", 
                       colour =  "chargePowerDelta") 
p <- p + 
  labs(y = "Charging rate (kW)",
       caption = "Fast charging (corrected) \n Pairs spanning midnight truncated at 23:59") +
  guides(colour = guide_legend(title = "Charge rate delta (kW)")) +
  scale_color_continuous(low = "green", high = "red") # highlight ones that went up
p
#ggsave("plots/fastChargePairs_kW_LineSegments.png", p, height = 10)
```


```{r checkFastSequencesSoC, fig.height=10, fig.cap="Fast charging (corrected) - state of charge"}
#dt <- dt[, SoC_pcDelta := SoC_pcDelta * -1] # invert so big drops become red in plot
p <- makeSeqChargePlot(dt, y = "startSoC_pc", 
                       yend = "endSoC_pc", 
                       colour =  "SoC_pcDelta")
p <- p + 
  labs(y = "State of charge (%)",
       caption = "Fast charging (corrected) \n Pairs spanning midnight truncated at 23:59") +
  guides(colour = guide_legend(title = "State of charge delta (%)")) +
  scale_color_continuous(low = "red", high = "green") # highlight ones that went down
p
#ggsave("plots/fastChargePairs_SoC_LineSegments.png", p, height = 10)
```


### Charge type

`chargeType` is used to classify charging events into standard vs fast using the 7 kW threshold. But there may be misclassfications where a sequence starts on a fast charger but power demand declines below the threshold. We can check this and have corrected it in some sections above using the start/end pairs.

```{r checkChargeType}
# Check chargeType ----

t <- table(firstLastDT$chargeTypeError, firstLastDT$chargeType, useNA = "always")

kableExtra::kable(t, caption = "chargeType errors detected") %>%
  kable_styling()

nError <- nrow(firstLastDT[chargeTypeError %like% "Error"])
nErrorEVs <- uniqueN(firstLastDT[chargeTypeError %like% "Error"]$dvID)  
message("There are ", nError, " pairs (out of a total of ", nrow(firstLastDT)/2,") from ", nErrorEVs ," EVs where charge type doesn't match.")
```


# References